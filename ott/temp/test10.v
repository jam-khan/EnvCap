(* generated by Ott 0.34 from: test10.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Definition var : Set := nat. (* term variable *)
Lemma eq_var: forall (x y : var), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
#[export] Hint Resolve eq_var : ott_coq_equality.

Inductive term : Set :=  (* term *)
 | t_var (x:var) (* variable *)
 | t_lam (x:var) (t:term) (* lambda *)
 | t_app (t:term) (t':term) (* app *).

(** subrules *)
Definition is_val_of_term (t5:term) : bool :=
  match t5 with
  | (t_var x) => false
  | (t_lam x t) => (true)
  | (t_app t t') => false
end.

(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.


(** substitutions *)
Fixpoint tsubst_term (t5:term) (x5:var) (t_6:term) {struct t_6} : term :=
  match t_6 with
  | (t_var x) => (if eq_var x x5 then t5 else (t_var x))
  | (t_lam x t) => t_lam x (if list_mem eq_var x5 (cons x nil) then t else (tsubst_term t5 x5 t))
  | (t_app t t') => t_app (tsubst_term t5 x5 t) (tsubst_term t5 x5 t')
end.

(* definitions *)

(* defns Jop *)
Inductive reduce : term -> term -> Prop :=    (* defn reduce *)
 | ax_app : forall (x:var) (t1 v2:term),
     Is_true (is_val_of_term v2) ->
     reduce (t_app  (t_lam x t1)  v2)  (tsubst_term  v2   x   t1 ) 
 | ctx_app_fun : forall (t1 t t1':term),
     reduce t1 t1' ->
     reduce (t_app t1 t) (t_app t1' t)
 | ctx_app_arg : forall (v t1 t1':term),
     Is_true (is_val_of_term v) ->
     reduce t1 t1' ->
     reduce (t_app v t1) (t_app v t1').



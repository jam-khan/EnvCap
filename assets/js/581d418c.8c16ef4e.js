"use strict";(self.webpackChunkenvcap_docs=self.webpackChunkenvcap_docs||[]).push([[905],{8043:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"syntax","title":"syntax","description":"Here\'s the complete syntax guide in a clean markdown format that you can save as a .md file:","source":"@site/docs/syntax.md","sourceDirName":".","slug":"/syntax","permalink":"/EnvCap/docs/syntax","draft":false,"unlisted":false,"editUrl":"https://github.com/jam-khan/Envcap/tree/main/docs/syntax.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar"}');var l=s(4848),i=s(8453);const r={},t=void 0,c={},d=[{value:"Imports and Requirements",id:"imports-and-requirements",level:3},{value:"Basic Syntax",id:"basic-syntax",level:2},{value:"Literals",id:"literals",level:3},{value:"Variables and Bindings",id:"variables-and-bindings",level:3},{value:"Functions",id:"functions",level:3},{value:"Types",id:"types",level:2},{value:"Basic Types",id:"basic-types",level:3},{value:"Composite Types",id:"composite-types",level:3},{value:"Expressions",id:"expressions",level:2},{value:"Arithmetic Operations",id:"arithmetic-operations",level:3},{value:"Comparisons",id:"comparisons",level:3},{value:"Boolean Operations",id:"boolean-operations",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"Environment Operations",id:"environment-operations",level:3},{value:"Modules",id:"modules",level:3},{value:"ADTs and Pattern Matching",id:"adts-and-pattern-matching",level:3},{value:"Lists",id:"lists",level:3},{value:"Separate Compilation",id:"separate-compilation",level:2},{value:"Interface Files",id:"interface-files",level:3},{value:"Capability System",id:"capability-system",level:2},{value:"Pure vs Resource Modules",id:"pure-vs-resource-modules",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Let Expressions",id:"let-expressions",level:3},{value:"Records",id:"records",level:3},{value:"Tuples",id:"tuples",level:3},{value:"Tagged Values",id:"tagged-values",level:3},{value:"Dependent Merges",id:"dependent-merges",level:3},{value:"First-class Environments",id:"first-class-environments",level:3}];function o(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.p,{children:["Here's the complete syntax guide in a clean markdown format that you can save as a ",(0,l.jsx)(n.code,{children:".md"})," file:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-markdown",children:"# ENVCAP Syntax Guide\n\n## Overview\nENVCAP is a statically-typed functional language that introduces three key innovations:\n1. First-class environments\n2. Capability-based first-class modules  \n3. Separate compilation with unified types and interfaces\n\n## Program Structure\n\n### Module Declarations\n```envcap\n@pure module ModuleName { ... }\n@resource module ModuleName { ... }\n"})}),"\n",(0,l.jsx)(n.h3,{id:"imports-and-requirements",children:"Imports and Requirements"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"import Module1, Module2;\nrequire Module3, Module4;\n"})}),"\n",(0,l.jsx)(n.h2,{id:"basic-syntax",children:"Basic Syntax"}),"\n",(0,l.jsx)(n.h3,{id:"literals",children:"Literals"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"42              // Integer\n\"hello\"         // String\n'world'         // Alternative string\nTrue            // Boolean\nFalse           // Boolean\nunit            // Unit value\n"})}),"\n",(0,l.jsx)(n.h3,{id:"variables-and-bindings",children:"Variables and Bindings"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:'val x = 42\nlet y = "hello"\nletrec { fact = \u03bb(n:Int).if n == 0 then 1 else n * fact(n-1) }\n'})}),"\n",(0,l.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"function add(x:Int, y:Int):Int { x + y }\n\u03bb(x:Int, y:Int).x + y         // Anonymous function\n"})}),"\n",(0,l.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,l.jsx)(n.h3,{id:"basic-types",children:"Basic Types"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"Int\nString\nBool\nUnit\n"})}),"\n",(0,l.jsx)(n.h3,{id:"composite-types",children:"Composite Types"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"A -> B         // Function type\n[A]            // List type\n{l:A}          // Record type\nA & B          // Intersection type\nA | B          // Union type\nSig[A,B]       // Module signature\n"})}),"\n",(0,l.jsx)(n.h2,{id:"expressions",children:"Expressions"}),"\n",(0,l.jsx)(n.h3,{id:"arithmetic-operations",children:"Arithmetic Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"x + y\nx - y  \nx * y\nx / y\nx % y\n"})}),"\n",(0,l.jsx)(n.h3,{id:"comparisons",children:"Comparisons"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"x == y\nx != y\nx < y\nx <= y\nx > y\nx >= y\n"})}),"\n",(0,l.jsx)(n.h3,{id:"boolean-operations",children:"Boolean Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"x && y\nx || y\n!x\n"})}),"\n",(0,l.jsx)(n.h3,{id:"control-flow",children:"Control Flow"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"if condition then e1 else e2\n\nmatch expr of\n  case pattern1 => e1\n  case pattern2 => e2\n"})}),"\n",(0,l.jsx)(n.h3,{id:"environment-operations",children:"Environment Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"env           // Current environment\nwith e1 in e2 // Evaluate e2 in environment e1\ne1 ,, e2      // Environment merge\ne.n           // Projection by index\ne.field       // Record field access\n"})}),"\n",(0,l.jsx)(n.h3,{id:"modules",children:"Modules"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"module M { ... }                     // Simple module\nfunctor F(x:A):B { ... }             // Functor (parameterized module)\nmodule struct(x:A) { ... }           // Anonymous module\nopen M(N)                            // Module instantiation\n"})}),"\n",(0,l.jsx)(n.h3,{id:"adts-and-pattern-matching",children:"ADTs and Pattern Matching"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"type Shape = Circle Int | Rectangle Int Int\n\nlet circ = {Circle 10} as Shape\n\nmatch shape of\n  case Circle r => ...\n  case Rectangle w h => ...\n"})}),"\n",(0,l.jsx)(n.h3,{id:"lists",children:"Lists"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"[1, 2, 3]<Int>          // Typed list\nmatch list of\n  case [] => ...\n  case (x:xs) => ...\n"})}),"\n",(0,l.jsx)(n.h2,{id:"separate-compilation",children:"Separate Compilation"}),"\n",(0,l.jsx)(n.h3,{id:"interface-files",children:"Interface Files"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"// File.epi\n@pure interface ModuleName\nrequire Dependency\nval x : Int\nfunction f(y:Int):Int\n"})}),"\n",(0,l.jsx)(n.h2,{id:"capability-system",children:"Capability System"}),"\n",(0,l.jsx)(n.h3,{id:"pure-vs-resource-modules",children:"Pure vs Resource Modules"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"@pure module PureModule {\n  // Can only import other pure modules\n  // Must receive resources as parameters\n}\n\n@resource module ResourceModule {\n  // Can import both pure and resource modules\n  // Can be passed as capabilities\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,l.jsx)(n.h3,{id:"let-expressions",children:"Let Expressions"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:'let {\n  x:Int = 1,\n  y:String = "test"\n} in {\n  x + length(y)\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"records",children:"Records"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:'{"field1" = 42, "field2" = "value"}\nrecord.field1\n'})}),"\n",(0,l.jsx)(n.h3,{id:"tuples",children:"Tuples"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:'(1, "two", True)\n'})}),"\n",(0,l.jsx)(n.h3,{id:"tagged-values",children:"Tagged Values"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"{Tag value1 value2} as Type\n"})}),"\n",(0,l.jsx)(n.h3,{id:"dependent-merges",children:"Dependent Merges"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:"e1 ,, e2   // e2 can depend on e1\n"})}),"\n",(0,l.jsx)(n.h3,{id:"first-class-environments",children:"First-class Environments"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-envcap",children:'let env1 = {"x"=1} ,, {"y"=2}\nwith env1 in env.x + env.y\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"\nYou can save this directly as `envcap_syntax.md`. The content is properly formatted with clear section headers and code blocks for all syntax examples.\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var a=s(6540);const l={},i=a.createContext(l);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);